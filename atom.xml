<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tenderlies的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://tenderlies.github.io/"/>
  <updated>2018-07-22T09:05:30.209Z</updated>
  <id>https://tenderlies.github.io/</id>
  
  <author>
    <name>Tenderlies</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微服务架构</title>
    <link href="https://tenderlies.github.io/2018/06/12/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/Micro-Service/"/>
    <id>https://tenderlies.github.io/2018/06/12/微服务架构/微服务架构/Micro-Service/</id>
    <published>2018-06-12T14:17:06.000Z</published>
    <updated>2018-07-22T09:05:30.209Z</updated>
    
    <content type="html"><![CDATA[<h1 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>微服务是一种系统架构风格。<br>想要了解微服务，最好阅读下面这位的大佬的博客，此文内容翻译自该博客。<br><code>Martin Fowler : https://martinfowler.com/articles/microservices.html</code></p><p>简而言之，微服务架构风格是一种将单个应用程序作为一套（拆分为多个）小型服务开发的方法，每个小型服务都在其自己的进程中运行，并与轻量级机制（通常是HTTP资源API，也就是RESTful API）进行通信。这些服务是<strong>围绕业务功能构建</strong>的，可以通过<strong>全自动化部署机制</strong>独立部署。这些服务的集中管理很少，可以用<strong>不同的编程语言</strong>编写，并使用<strong>不同的数据存储技术</strong>。</p><p><code>In short, the microservice architectural style is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery. There is a bare minimum of centralized management of these services, which may be written in different programming languages and use different data storage technologies.</code></p><p>在解释微服务风格之前，将其与整体风格（将整体应用程序构建为一个单独的单元）进行比较是非常有用的。企业应用程序通常建立在三个主要部分中：一个客户端用户界面（由用户计算机上的浏览器中运行的HTML页面和JavaScript组成）数据库（包括多个表构成的通用的、相互关联的数据库管理系统）和一个服务器端应用程序。服务器端应用程序将处理HTTP请求，执行领域逻辑，从数据库检索和更新数据，选择并填充要发送到浏览器的HTML视图。这个服务器端应用程序是一个庞然大物 – 一个逻辑可执行文件。系统的任何更改都涉及构建和部署新版本的服务器端应用程序。</p><p><code>To start explaining the microservice style it&#39;s useful to compare it to the monolithic style: a monolithic application built as a single unit. Enterprise Applications are often built in three main parts: a client-side user interface (consisting of HTML pages and javascript running in a browser on the user&#39;s machine) a database (consisting of many tables inserted into a common, and usually relational, database management system), and a server-side application. The server-side application will handle HTTP requests, execute domain logic, retrieve and update data from the database, and select and populate HTML views to be sent to the browser. This server-side application is a monolith - a single logical executable. Any changes to the system involve building and deploying a new version of the server-side application.</code></p><p>使用这种整体的服务端构建系统是一种自然的方式。处理请求的所有逻辑都在一个进程中运行，你可以使用语言的基本功能将应用程序划分为类，函数和名称空间。在某些场景中，你可以在开发人员的笔记本电脑上运行和测试应用程序，并使用部署管道来确保更改经过正常的测试并部署到生产环境中。你也可以结合负载均衡启动多个应用实例将应用横向扩展。</p><p><code>Such a monolithic server is a natural way to approach building such a system. All your logic for handling a request runs in a single process, allowing you to use the basic features of your language to divide up the application into classes, functions, and namespaces. With some care, you can run and test the application on a developer&#39;s laptop, and use a deployment pipeline to ensure that changes are properly tested and deployed into production. You can horizontally scale the monolith by running many instances behind a load-balancer.</code></p><p>整体应用程序相当不错，但越来越多的人感到沮丧 — 尤其是越来越多的应用程序部署到云中。变更周期被绑定在一起  — 即使只对应用程序的一小部分进行更改，仍需要重新构建和部署整个整体。随着时间的推移，通常很难保持良好的模块化结构，使得一个模块的变更很难不影响到其它模块。扩展就需要扩展整个应用程序，而不能只扩展程序中更需要扩展的模块。</p><p><code>Monolithic applications can be successful, but increasingly people are feeling frustrations with them - especially as more applications are being deployed to the cloud . Change cycles are tied together - a change made to a small part of the application, requires the entire monolith to be rebuilt and deployed. Over time it&#39;s often hard to keep a good modular structure, making it harder to keep changes that ought to only affect one module within that module. Scaling requires scaling of the entire application rather than parts of it that require greater resource.</code></p><p><img src="https://martinfowler.com/articles/microservices/images/sketch.png" alt="Sketch"></p><p>这种挫败感导致了微服务架构风格的出现：将应用程序构建为一套服务。除了可独立部署和扩展之外，每种服务还提供了一个牢固的模块边界，甚至允许用不同的编程语言编写不同的服务。它们也可以由不同的团队管理。</p><p><code>These frustrations have led to the microservice architectural style: building applications as suites of services. As well as the fact that services are independently deployable and scalable, each service also provides a firm module boundary, even allowing for different services to be written in different programming languages. They can also be managed by different teams .</code></p><p>我们并不认为微服务风格是什么新东西，它的根源至少可以追溯到Unix的设计原则。但我们确实认为考虑微服务体系结构的人不多，如果他们使用它，许多软件开发都会变得更好。</p><p><code>We do not claim that the microservice style is novel or innovative, its roots go back at least to the design principles of Unix. But we do think that not enough people consider a microservice architecture and that many software developments would be better off if they used it.</code></p><h2 id="微服务架构的特性"><a href="#微服务架构的特性" class="headerlink" title="微服务架构的特性"></a>微服务架构的特性</h2><p>微服务架构风格还没有一个正式的定义，但我们可以尝试描述一下微服务风格所具有的共同特征。与任何描述共同特征的定义一样，并不是所有的微服务都要具有这些特性，但我们仍希望大多数微服务架构都具有大部分的特征。我们这些作者一直是这个相当宽松的社区的积极成员，我们的目的是尝试描述我们在自己的工作中所看到的以及团队中我们所知道的类似努力。重要的是，我们不制定那些明确的定义。</p><p><code>We cannot say there is a formal definition of the microservices architectural style, but we can attempt to describe what we see as common characteristics for architectures that fit the label. As with any definition that outlines common characteristics, not all microservice architectures have all the characteristics, but we do expect that most microservice architectures exhibit most characteristics. While we authors have been active members of this rather loose community, our intention is to attempt a description of what we see in our own work and in similar efforts by teams we know of. In particular we are not laying down some definition to conform to.</code></p><h3 id="服务组件化"><a href="#服务组件化" class="headerlink" title="服务组件化"></a>服务组件化</h3><p>自从我们开始软件行业以来，一直希望将组件集成在一起来构建系统，就像我们在物理世界所看到的一样。在过去的几十年里，我们已经大部分语言平台的大量公共库取得了相当的进步。</p><p><code>For as long as we&#39;ve been involved in the software industry, there&#39;s been a desire to build systems by plugging together components, much in the way we see things are made in the physical world. During the last couple of decades we&#39;ve seen considerable progress with large compendiums of common libraries that are part of most language platforms.</code></p><p>当我们谈论组件时，可能会陷入一个困境：什么是组件？我们的定义是，<strong>组件</strong>（<strong>component</strong>）是一个可独立替换和升级的软件单元。</p><p><code>When talking about components we run into the difficult definition of what makes a component. Our definition is that a component is a unit of software that is independently replaceable and upgradeable.</code></p><p>微服务架构会使用库，但它将软件组件化的主要方式是把软件拆分成多个服务。我们把库定义为链接到程序并通过内存中函数调用来调用的组件，而服务是进程外组件，<strong>服务利用某个机制通信</strong>，比如 Web 服务请求或远程过程调用（RPC）。（组件和服务在很多面向对象编程中是不同的概念。）</p><p><code>Microservice architectures will use libraries, but their primary way of componentizing their own software is by breaking down into services. We define libraries as components that are linked into a program and called using in-memory function calls, while services are out-of-process components who communicate with a mechanism such as a web service request, or remote procedure call. (This is a different concept to that of a service object in many OO programs.)</code></p><p>把服务当作组件（而不是组件库）的一个主要原因是<strong>服务可以独立部署</strong>。如果你有一个由很多库组成的单独进程的应用程序，则任何一个组件的更改都将导致必须重新部署整个应用程序。但是，如果将应用程序分解成多个服务，那你只需要重新部署那个改变的服务。当然，这也不是绝对的，有些协作中的小改变会更改服务接口，但是一个好的微服务架构的目标就是通过在服务契约中解耦服务的边界和可进化机制来最小化这些问题。</p><p><code>One main reason for using services as components (rather than libraries) is that services are independently deployable. If you have an application that consists of a multiple libraries in a single process, a change to any single component results in having to redeploy the entire application. But if that application is decomposed into multiple services, you can expect many single service changes to only require that service to be redeployed. That&#39;s not an absolute, some changes will change service interfaces resulting in some coordination, but the aim of a good microservice architecture is to minimize these through cohesive service boundaries and evolution mechanisms in the service contracts.</code></p><p>将服务当作组件的另一个结果是拥有更明确的组件接口。大多数语言都没有一个良好的机制来定义一个发布的接口。通常会通过文档和规范避免客户端破坏组件的封装性，阻止组件间紧耦合。服务可通过显式远程调用机制很轻松的避免这种情况。</p><p><code>Another consequence of using services as components is a more explicit component interface. Most languages do not have a good mechanism for defining an explicit Published Interface. Often it&#39;s only documentation and discipline that prevents clients breaking a component&#39;s encapsulation, leading to overly-tight coupling between components. Services make it easier to avoid this by using explicit remote call mechanisms.</code></p><p>使用服务也有缺点。远程调用比进制内调用更消耗资源，因此远程 API 需要粗粒度，但这通常更难以使用。如果你需要调整组件间的职责分配，当你跨越进程边界时，这种行为的调整就会变得更难。</p><p><code>Using services like this does have downsides. Remote calls are more expensive than in-process calls, and thus remote APIs need to be coarser-grained, which is often more awkward to use. If you need to change the allocation of responsibilities between components, such movements of behavior are harder to do when you&#39;re crossing process boundaries.</code></p><p>一个可能是，我们能够观察映射服务的运行时进程，但也只是一个可能。服务可以由多个进程组成，它们会同时开发和部署，例如一个应用程序进程和一个只能由这个服务使用的数据库。</p><p><code>At a first approximation, we can observe that services map to runtime processes, but that is only a first approximation. A service may consist of multiple processes that will always be developed and deployed together, such as an application process and a database that&#39;s only used by that service.</code></p><h3 id="围绕业务功能的组织"><a href="#围绕业务功能的组织" class="headerlink" title="围绕业务功能的组织"></a>围绕业务功能的组织</h3><p>在将大型应用程序拆分为多个部分时，管理通常会关注在技术层，就会出现UI团队、服务器端逻辑团队和数据库团队。当按照这些标准划分团队时，即使是简单的更改也可能导致跨团队项目合作，从而消耗时间和预算审批。一个聪明的团队将围绕这个进行优化，两害相权取其轻——只需将逻辑强制应用到他们可以访问的任何应用程序中。换句话说，逻辑无处不在。这是康威定律的一个例子。</p><p><code>When looking to split a large application into parts, often management focuses on the technology layer, leading to UI teams, server-side logic teams, and database teams. When teams are separated along these lines, even simple changes can lead to a cross-team project taking time and budgetary approval. A smart team will optimise around this and plump for the lesser of two evils - just force the logic into whichever application they have access to. Logic everywhere in other words. This is an example of Conway&#39;s Law in action.</code></p><pre><code>Any organization that designs a system (defined broadly) will produce a design whose structure is a copy of the organization&apos;s communication structure.-- Melvyn Conway, 1967</code></pre><p><img src="https://martinfowler.com/articles/microservices/images/conways-law.png" alt="Conways Law"></p><p>微服务的划分方法不同，它倾向围绕业务能力组织来切割服务。此类服务为该业务领域采用广泛的软件实现，包括用户界面，持久化存储和任何外部协作。因此，团队是跨职能的，包含开发过程所要求的所有技能：用户体验、数据库和项目管理。</p><p><code>The microservice approach to division is different, splitting up into services organized around business capability. Such services take a broad-stack implementation of software for that business area, including user-interface, persistant storage, and any external collaborations. Consequently the teams are cross-functional, including the full range of skills required for the development: user-experience, database, and project management.</code></p><p><img src="https://martinfowler.com/articles/microservices/images/PreferFunctionalStaffOrganization.png" alt="PreferFunctionalStaffOrganization"></p><p><a href="http://www.comparethemarket.com就是一家以这种方式组建的公司。跨职能团队负责构建和运营每个产品，每个产品分为多个独立的服务，服务间通过消息总线进行通信。" target="_blank" rel="noopener">www.comparethemarket.com就是一家以这种方式组建的公司。跨职能团队负责构建和运营每个产品，每个产品分为多个独立的服务，服务间通过消息总线进行通信。</a></p><p><code>One company organised in this way is www.comparethemarket.com. Cross functional teams are responsible for building and operating each product and each product is split out into a number of individual services communicating via a message bus.</code></p><p>大型的整体应用程序也可以按照业务功能进行模块化，尽管这种情况不常见。当然，我们可以敦促一个构建整体应用程序的大型团队，按业务线来分割自己。我们已经看到的主要问题是，它们往往围绕太多的前后关系进行组织。如果整体应用程序跨越很多模块边界，这不适合团队的个别成员短期记忆。此外，我们发现模块化需要大量的强制规范。服务组件所需的更明确的分离使得保持团队边界清晰更容易。</p><p><code>Large monolithic applications can always be modularized around business capabilities too, although that&#39;s not the common case. Certainly we would urge a large team building a monolithic application to divide itself along business lines. The main issue we have seen here, is that they tend to be organised around too many contexts. If the monolith spans many of these modular boundaries it can be difficult for individual members of a team to fit them into their short-term memory. Additionally we see that the modular lines require a great deal of discipline to enforce. The necessarily more explicit separation required by service components makes it easier to keep the team boundaries clear.</code></p><h3 id="产品非项目"><a href="#产品非项目" class="headerlink" title="产品非项目"></a>产品非项目</h3><p>我们看到的大多数应用程序开发工作都使用这样的项目模式：致力于提供一些被认为是完整的软件。软件完成后，将移交给维护组织，构建它的项目团队将被解散。</p><p><code>Most application development efforts that we see use a project model: where the aim is to deliver some piece of software which is then considered to be completed. On completion the software is handed over to a maintenance organization and the project team that built it is disbanded.</code></p><p>微服务的支持者认为这种做法是不可取的，并提议团队应该负责产品的整个生命周期。对此一个共同的启示是 Amazon 的 “you build, you run it” 理念，要求开发团队对软件产品的整个生命周期负责。这要求开发者每天都关注他们的软件运行情况，增加与用户的联系，同时承担一些售后支持。</p><p><code>Microservice proponents tend to avoid this model, preferring instead the notion that a team should own a product over its full lifetime. A common inspiration for this is Amazon&#39;s notion of &quot;you build, you run it&quot; where a development team takes full responsibility for the software in production. This brings developers into day-to-day contact with how their software behaves in production and increases contact with their users, as they have to take on at least some of the support burden.</code></p><p>产品的理念，跟业务能力紧密相连。不是将软件视为一组要完成的功能，而是一种持续的关系，是如何让软件帮助用户增强业务能力。</p><p><code>The product mentality, ties in with the linkage to business capabilities. Rather than looking at the software as a set of functionality to be completed, there is an on-going relationship where the question is how can software assist its users to enhance the business capability.</code></p><p>为什么这种方法不能用于整体应用程序是没有理由的，但更小的服务粒度可以使服务开发人员与其用户之间的个人关系变得更容易。</p><p><code>There&#39;s no reason why this same approach can&#39;t be taken with monolithic applications, but the smaller granularity of services can make it easier to create the personal relationships between service developers and their users.</code></p><h3 id="智能端点以及傻瓜通道"><a href="#智能端点以及傻瓜通道" class="headerlink" title="智能端点以及傻瓜通道"></a>智能端点以及傻瓜通道</h3><p>在不同进程之间建立通信机制的时时候，我们已经看到有许多产品和方法都强调将重要的智能放入通信机制中。一个很好的例子就是企业服务总线（ESB），其中ESB产品通常提供复杂的工具用于消息路由、编排、传输和应用业务规则。</p><p><code>When building communication structures between different processes, we&#39;ve seen many products and approaches that stress putting significant smarts into the communication mechanism itself. A good example of this is the Enterprise Service Bus (ESB), where ESB products often include sophisticated facilities for message routing, choreography, transformation, and applying business rules.</code></p><p>微服务社区倾向于采用另一种方法：智能端点和傻瓜通道。微服务构建的应用旨在尽可能的松耦合和高内聚：它们拥有自己的域逻辑，并且更像是传统Unix意义上的过滤器——接收请求、适当地处理逻辑、返回响应。这些是使用简单的 RESTish 协议，而不是诸如WS-Choreography、BPEL、集中式框架等复杂的协议。</p><p><code>The microservice community favours an alternative approach: smart endpoints and dumb pipes. Applications built from microservices aim to be as decoupled and as cohesive as possible - they own their own domain logic and act more as filters in the classical Unix sense - receiving a request, applying logic as appropriate and producing a response. These are choreographed using simple RESTish protocols rather than complex protocols such as WS-Choreography or BPEL or orchestration by a central tool.</code></p><p>最常用的两种协议是：具有资源API的HTTP请求-响应和轻量级消息传递。第一种途径最好的表达方式是：Be of the web, not behind the web.</p><p><code>The two protocols used most commonly are HTTP request-response with resource API&#39;s and lightweight messaging. The best expression of the first is</code></p><pre><code>Be of the web, not behind the web-- Ian Robinson</code></pre><p>微服务团队采用万维网（广义上，包含Unix系统）建立的原则和规范。这样经常使用的资源可以通过开发者或者操作人员以非常小的代价来缓存。</p><p><code>Microservice teams use the principles and protocols that the world wide web (and to a large extent, Unix) is built on. Often used resources can be cached with very little effort on the part of developers or operations folk.</code></p><p>常用的第二种途径是通过轻量级消息总线进行消息传递。这种通信协议非常的傻瓜（傻瓜到只负责消息路由），像RabbitMQ或者ZeroMQ这样的简单实现甚至只提供了可靠的异步机制，但生产和消费信息的智能仍然存在于在服务终端中。</p><p><code>The second approach in common use is messaging over a lightweight message bus. The infrastructure chosen is typically dumb (dumb as in acts as a message router only) - simple implementations such as RabbitMQ or ZeroMQ don&#39;t do much more than provide a reliable asynchronous fabric - the smarts still live in the end points that are producing and consuming messages; in the services.</code></p><p>在整体应用程序中，组件在进程内执行，它们之间的通信是通过方法调用或函数调用。从整体式风格到微服务架构最大的问题在于通信模式的变化。从内存中方法调用到RPC的简单转换会导致健壮的通信无法正常执行。反而，你得用粗粒度的途径替换细粒度的通信。</p><p><code>In a monolith, the components are executing in-process and communication between them is via either method invocation or function call. The biggest issue in changing a monolith into microservices lies in changing the communication pattern. A naive conversion from in-memory method calls to RPC leads to chatty communications which don&#39;t perform well. Instead you need to replace the fine-grained communication with a coarser-grained approach.</code></p><h3 id="分散治理"><a href="#分散治理" class="headerlink" title="分散治理"></a>分散治理</h3><p>一种集中式治理的结果是在单一技术平台趋于标准化。经验表明，这种途径是有限的——并非每个问题都是钉子也不是每个解决方案都是锤子。我们更喜欢使用适当的工具来完成工作，而整体应用程序可以在一定程度上利用不同的语言，但这并不常见。</p><p><code>One of the consequences of centralised governance is the tendency to standardise on single technology platforms. Experience shows that this approach is constricting - not every problem is a nail and not every solution a hammer. We prefer using the right tool for the job and while monolithic applications can take advantage of different languages to a certain extent, it isn&#39;t that common.</code></p><p>将整体应用中的组件拆分为服务，我们可以在构建每个组件时做出选择。你想使用Node.js开发一个简单的报告页面吗？去吧。C++ 适用于实时性组件？可以。你想要在不同类型的数据库中切换，来切合组件的读取性能？我们现在有技术手段来实现它了。</p><p><code>Splitting the monolith&#39;s components out into services we have a choice when building each of them. You want to use Node.js to standup a simple reports page? Go for it. C++ for a particularly gnarly near-real-time component? Fine. You want to swap in a different flavour of database that better suits the read behaviour of one component? We have the technology to rebuild him.</code></p><p>当然，仅仅因为你可以做某事，并不意味着你应该这样做——但以这种方式划分你的系统意味着你可以选择。</p><p><code>Of course, just because you can do something, doesn&#39;t mean you should - but partitioning your system in this way means you have the option.</code></p><p>构建微服务的团队也更喜欢采用不同的标准方法。他们不是使用在纸上某处写下的一组定义标准，而是更愿意开发出有用的工具，这样其他开发人员可以使用该工具来解决类似的问题。这些工具通常从实现中成长起来，并在的广泛范围内分享，有时，但不仅仅是使用内部开源模式。现在git和github已成为事实上的版本控制系统，开源实践在内部变得越来越普遍。</p><p><code>Teams building microservices prefer a different approach to standards too. Rather than use a set of defined standards written down somewhere on paper they prefer the idea of producing useful tools that other developers can use to solve similar problems to the ones they are facing. These tools are usually harvested from implementations and shared with a wider group, sometimes, but not exclusively using an internal open source model. Now that git and github have become the de facto version control system of choice, open source practices are becoming more and more common in-house.</code></p><p>Netflix是遵循这一理念的组织的一个很好的例子。共享有用的，最重要的是，经过实战考验的代码，例如共享库，激励着其他开发者以相似的方式解决相似的问题，但如果需要，可以选择不同的方法。共享库更关注于数据存储、进程内通信以及我们将在下面进一步讨论基础设施自动化。。</p><p><code>Netflix is a good example of an organisation that follows this philosophy. Sharing useful and, above all, battle-tested code as libraries encourages other developers to solve similar problems in similar ways yet leaves the door open to picking a different approach if required. Shared libraries tend to be focused on common problems of data storage, inter-process communication and as we discuss further below, infrastructure automation.</code></p><p>对于微服务社区来说，服务契约问题特别缺乏吸引力。这并不是说社区不重视服务契约。恰恰相反，会更加的重视。只是他们正在寻找管理这些契约的不同方式。如<strong>读者容错模式</strong>和<strong>消费者驱动契约</strong>这样的模式通常应用于微服务。这些模式帮助服务契约独立的发展。在构建过程中执行消费者驱动契约可以增强信心并快速反馈您的服务是否正常运行。事实上，我们知道澳大利亚的一个团队通过消费者驱动契约开发一个新的服务。他们使用简单的工具来定义服务契约。在编写新服务的代码之前，这将成为自动化构建的一部分。然后，该服务仅在满足契约的情况下构建——这是在构建新软件时避免’YAGNI’困境的优雅方法。这些技术和工具在使用过程中完善，通过减少服务间的耦合，限制了集中式管理的需要。</p><p><code>For the microservice community, overheads are particularly unattractive. That isn&#39;t to say that the community doesn&#39;t value service contracts. Quite the opposite, since there tend to be many more of them. It&#39;s just that they are looking at different ways of managing those contracts. Patterns like Tolerant Reader and Consumer-Driven Contracts are often applied to microservices. These aid service contracts in evolving independently. Executing consumer driven contracts as part of your build increases confidence and provides fast feedback on whether your services are functioning. Indeed we know of a team in Australia who drive the build of new services with consumer driven contracts. They use simple tools that allow them to define the contract for a service. This becomes part of the automated build before code for the new service is even written. The service is then built out only to the point where it satisfies the contract - an elegant approach to avoid the &#39;YAGNI&#39; dilemma when building new software. These techniques and the tooling growing up around them, limit the need for central contract management by decreasing the temporal coupling between services.</code></p><p>也许分散治理的最高点是亚马逊推广build it / run it的理念。团队为他们开发的软件负所有责任，包括全天候的运行。这种层次的责任绝对不是常态，但我们确实看到越来越多的公司将责任推向开发团队。Netflix是另一个采用这种理念的组织。每天晚上凌晨3点被寻呼机唤醒肯定是在编写代码时注重质量的强大动力。这些想法与传统的集中治理模式相差甚远。</p><p><code>Perhaps the apogee of decentralised governance is the build it / run it ethos popularised by Amazon. Teams are responsible for all aspects of the software they build including operating the software 24/7. Devolution of this level of responsibility is definitely not the norm but we do see more and more companies pushing responsibility to the development teams. Netflix is another organisation that has adopted this ethos. Being woken up at 3am every night by your pager is certainly a powerful incentive to focus on quality when writing your code. These ideas are about as far away from the traditional centralized governance model as it is possible to be.</code></p><h3 id="分散数据管理"><a href="#分散数据管理" class="headerlink" title="分散数据管理"></a>分散数据管理</h3><p>数据管理的分散化以多种不同的方式呈现。最为抽象层次，它意味着不同系统中的世界的概念模型是不同的。这是在大型企业中集成时的常见问题，客户的销售视图将与支持视图不同。销售视图中称为客户的某些内容可能根本不会出现在支持视图中。这些情况可能是由于视图中具有不同的属性或者具有不同语意的共同属性（更糟糕）。</p><p><code>Decentralization of data management presents in a number of different ways. At the most abstract level, it means that the conceptual model of the world will differ between systems. This is a common issue when integrating across a large enterprise, the sales view of a customer will differ from the support view. Some things that are called customers in the sales view may not appear at all in the support view. Those that do may have different attributes and (worse) common attributes with subtly different semantics.</code></p><p>此问题在应用程序之间很常见，但也可能在应用程序中发生，特别是当该应用程序拆分为组件时。一种有用的想法是为有界上下文的领域驱动设计（DDD）。DDD将复杂域划分为多个有界上下文，并映射出它们之间的关系。此过程对整体风格和微服务体系结构都很有用，但服务和上下文边界之间存在自然关联，这有助于澄清，正如我们在业务功能部分中所述，强化了分离。</p><p><code>This issue is common between applications, but can also occur within applications, particular when that application is divided into separate components. A useful way of thinking about this is the Domain-Driven Design notion of Bounded Context. DDD divides a complex domain up into multiple bounded contexts and maps out the relationships between them. This process is useful for both monolithic and microservice architectures, but there is a natural correlation between service and context boundaries that helps clarify, and as we describe in the section on business capabilities, reinforce the separations.</code></p><p>除了关于概念模型的分散决策之外，微服务还分散了数据存储决策。虽然单个应用程序更喜欢单个逻辑数据库来存储持久性数据，但企业通常更喜欢跨越一系列应用程序的单个数据库——其中许多决策是根据供应商的商业许可模式推动的。微服务更喜欢让每个服务管理自己的数据库，可以是相同数据库技术的不同实例，也可以是完全不同的数据库系统——这种方法称为<strong>混合持久化</strong>。你可以在整体风格中使用<strong>混合持久化</strong>，但它在微服务中更常出现。</p><p><code>As well as decentralizing decisions about conceptual models, microservices also decentralize data storage decisions. While monolithic applications prefer a single logical database for persistant data, enterprises often prefer a single database across a range of applications - many of these decisions driven through vendor&#39;s commercial models around licensing. Microservices prefer letting each service manage its own database, either different instances of the same database technology, or entirely different database systems - an approach called Polyglot Persistence. You can use polyglot persistence in a monolith, but it appears more frequently with microservices.</code></p><p><img src="https://martinfowler.com/articles/microservices/images/decentralised-data.png" alt="Decentralised Data"></p><p>跨微服务分散数据责任对管理更新有影响。处理更新的常用方法是在更新多个资源时使用事务来保证一致性。这种方法通常用于整体结构中。</p><p><code>Decentralizing responsibility for data across microservices has implications for managing updates. The common approach to dealing with updates has been to use transactions to guarantee consistency when updating multiple resources. This approach is often used within monoliths.</code></p><p>使用这样的事务有助于保持一致性，但会产生显著的时间耦合，这在多个服务中是有问题的。众所周知，分布式事务很难实现，因此微服务架构强调服务之间的无事务协调，明确认识到一致性可能只是最终的一致性，而问题则通过补偿操作来处理。</p><p><code>Using transactions like this helps with consistency, but imposes significant temporal coupling, which is problematic across multiple services. Distributed transactions are notoriously difficult to implement and as a consequence microservice architectures emphasize transactionless coordination between services, with explicit recognition that consistency may only be eventual consistency and problems are dealt with by compensating operations.</code></p><p>选择以这种方式管理不一致性是许多开发团队面临的新挑战，但它通常与业务实践相匹配。企业通常会处理一定程度的不一致性，以便快速响应需求，同时采取某种逆转流程来应对错误。只要修复错误的成本低于在强一致性下丢失业务的成本，这种交易是值得的。</p><p><code>Choosing to manage inconsistencies in this way is a new challenge for many development teams, but it is one that often matches business practice. Often businesses handle a degree of inconsistency in order to respond quickly to demand, while having some kind of reversal process to deal with mistakes. The trade-off is worth it as long as the cost of fixing mistakes is less than the cost of lost business under greater consistency.</code></p><h3 id="基础设施自动化"><a href="#基础设施自动化" class="headerlink" title="基础设施自动化"></a>基础设施自动化</h3><p>基础设施自动化技术在过去几年中发生了巨大变化——特别是云和 AWS 的发展降低了构建、部署和操作微服务的复杂性。</p><p><code>Infrastructure automation techniques have evolved enormously over the last few years - the evolution of the cloud and AWS in particular has reduced the operational complexity of building, deploying and operating microservices.</code></p><p>许多使用微服务构建的产品或系统，它们的团队具有丰富的持续交付以及它的前驱持续集成的经验。以这种方式构建软件的团队广泛使用基础设施自动化技术。这在下面显示的构建管道中说明：</p><p><code>Many of the products or systems being build with microservices are being built by teams with extensive experience of Continuous Delivery and it&#39;s precursor, Continuous Integration. Teams building software this way make extensive use of infrastructure automation techniques. This is illustrated in the build pipeline shown below.</code></p><p><img src="https://martinfowler.com/articles/microservices/images/basic-pipeline.png" alt="Basic pipeline"></p><p>由于这不是关于持续交付的文章，我们将在这里介绍一下几个关键功能。我们希望有更多我们的软件正在运行的信心，因此我们运行了大量的自动化测试。促进正在运行的软件“上”管道意味着我们自动化部署到每个新环境。</p><p><code>Since this isn&#39;t an article on Continuous Delivery we will call attention to just a couple of key features here. We want as much confidence as possible that our software is working, so we run lots of automated tests. Promotion of working software &#39;up&#39; the pipeline means we automate deployment to each new environment.</code></p><p>整体应用程序能非常快乐的构建、测试并推送至环境。事实证明，一旦你打算投资一条整体应用自动化生产线，那么部署更多的应用程序似乎不再那么可怕了。请记住，持续交付(CD)的目标之一是使部署无聊，所以无论是一个还是三个应用程序，只要它仍然无聊就没关系。</p><p><code>A monolithic application will be built, tested and pushed through these environments quite happlily. It turns out that once you have invested in automating the path to production for a monolith, then deploying more applications doesn&#39;t seem so scary any more. Remember, one of the aims of CD is to make deployment boring, so whether its one or three applications, as long as its still boring it doesn&#39;t matter.</code></p><p>我们看到团队使用广泛的基础设施自动化的另一个领域是管理生产中的微服务。相比之下，只要部署很无聊，整体应用和微服务之间没有太大的区别，尽管发布的环境可能会截然不同。</p><p><code>Another area where we see teams using extensive infrastructure automation is when managing microservices in production. In contrast to our assertion above that as long as deployment is boring there isn&#39;t that much difference between monoliths and microservices, the operational landscape for each can be strikingly different.</code></p><p><img src="https://martinfowler.com/articles/microservices/images/micro-deployment.png" alt="Micro Deployment"></p><h3 id="容错性设计"><a href="#容错性设计" class="headerlink" title="容错性设计"></a>容错性设计</h3><p>使用服务作为组件的一个结果是，应用程序需要有能够容忍服务故障的设计。任何服务都可能因为供应商不可用而故障，客户端必须尽可能优雅地对此做出响应。与整体风格相比，这是一个缺点，因为它引入了额外的复杂性来处理它。这让微服务团队不断反思服务失败时对用户体验的影响。Netflix的Simian Army有引发服务故障、甚至在工作日引发数据中心故障的功能，以便测试应用程序的弹性和监控。</p><p><code>A consequence of using services as components, is that applications need to be designed so that they can tolerate the failure of services. Any service call could fail due to unavailability of the supplier, the client has to respond to this as gracefully as possible. This is a disadvantage compared to a monolithic design as it introduces additional complexity to handle it. The consequence is that microservice teams constantly reflect on how service failures affect the user experience. Netflix&#39;s Simian Army induces failures of services and even datacenters during the working day to test both the application&#39;s resilience and monitoring.</code></p><p>这种生产中的自动化测试足以让大多数运维团队正常的上下班。这并不是说整体风格不具备复杂的监控设置，只是在我们的经验中它不常见。</p><p><code>This kind of automated testing in production would be enough to give most operation groups the kind of shivers usually preceding a week off work. This isn&#39;t to say that monolithic architectural styles aren&#39;t capable of sophisticated monitoring setups - it&#39;s just less common in our experience.</code></p><p>由于服务可能随时故障，因此能够快速检测故障并尽可能自动恢复服务非常重要。微服务应用程序非常重视应用程序的实时监控，检查架构元素（数据库每秒获得多少请求）和业务相关度量（例如每分钟收到多少订单）。语义监控可以提供一种早期故障告警系统，让开发团队跟进和调查。</p><p><code>Since services can fail at any time, it&#39;s important to be able to detect the failures quickly and, if possible, automatically restore service. Microservice applications put a lot of emphasis on real-time monitoring of the application, checking both architectural elements (how many requests per second is the database getting) and business relevant metrics (such as how many orders per minute are received). Semantic monitoring can provide an early warning system of something going wrong that triggers development teams to follow up and investigate.</code></p><p>这对于微服务架构尤为重要，因为微服务偏好的编排和协作可能会导致紧急行为。虽然许多权威人士赞扬偶然的紧急行为价值，但事实是紧急行为有时可能是灾难。监控是至关重要的，它能快速发现这种紧急不良行为，让我们迅速修复它。</p><p><code>This is particularly important to a microservices architecture because the microservice preference towards choreography and event collaboration leads to emergent behavior. While many pundits praise the value of serendipitous emergence, the truth is that emergent behavior can sometimes be a bad thing. Monitoring is vital to spot bad emergent behavior quickly so it can be fixed.</code></p><p>整体结构可以像微服务一样透明——事实上，它们应该是。不同之处在于您绝对需要知道在不同进程间运行的服务何时断开连接。对于同一进程中的库，这种透明性不太可能有用。</p><p><code>Monoliths can be built to be as transparent as a microservice - in fact, they should be. The difference is that you absolutely need to know when services running in different processes are disconnected. With libraries within the same process this kind of transparency is less likely to be useful.</code></p><p>微服务团队希望看到针对每个服务的复杂监控和日志记录，比如显示上/下线状态的仪表盘、各种运维和业务相关的指标。断路器状态、当前吞吐量和延迟的详细信息是我们经常遇到的其他例子。</p><p><code>Microservice teams would expect to see sophisticated monitoring and logging setups for each individual service such as dashboards showing up/down status and a variety of operational and business relevant metrics. Details on circuit breaker status, current throughput and latency are other examples we often encounter in the wild.</code></p><h3 id="演进式设计"><a href="#演进式设计" class="headerlink" title="演进式设计"></a>演进式设计</h3><p>微服务实践者通常不断改进设计背景，并将服务分解视为更进一步的工具。这种工具使开发者在不会降低变更速度的情况下能够控制应用程序中的更改。变更控制并不一定意味减少变更——通过正确的态度和工具，您可以对软件进行频繁、快速和可控的更改。</p><p><code>Microservice practitioners, usually have come from an evolutionary design background and see service decomposition as a further tool to enable application developers to control changes in their application without slowing down change. Change control doesn&#39;t necessarily mean change reduction - with the right attitudes and tools you can make frequent, fast, and well-controlled changes to software.</code></p><p>每当您尝试将软件系统分解为组件时，您就面临着如何拆分的问题——那我们决定拆分应用程序的原则是什么？组件的关键属性在于独立替换和可升级，这暗示着我们寻找的关键在于，我们能设想重写一个组件而不影响其协作关系。实际上，许多微服务组明确给出了进一步预期：许多服务应被废弃而不是长久的发展。</p><p><code>Whenever you try to break a software system into components, you&#39;re faced with the decision of how to divide up the pieces - what are the principles on which we decide to slice up our application? The key property of a component is the notion of independent replacement and upgradeability - which implies we look for points where we can imagine rewriting a component without affecting its collaborators. Indeed many microservice groups take this further by explicitly expecting many services to be scrapped rather than evolved in the longer term.</code></p><p>Guardian网站是很好的例子，它初期被设计和构建为一个整体应用程序，但是它在微服务方向上发展。整体风格仍然是网站的核心，但他们更喜欢使用微服务构建来添加那些使用了整体风格 API 的新功能。这种方法来添加临时的功能非常方便，例如处理体育赛事的特稿。网站的这一部分可以使用适合快速开发的语言整合起来，并在事件结束后删除。我们在金融机构看到过类似的方法，为市场机会增加新服务，并在几个月甚至几周后撤销。</p><p><code>The Guardian website is a good example of an application that was designed and built as a monolith, but has been evolving in a microservice direction. The monolith still is the core of the website, but they prefer to add new features by building microservices that use the monolith&#39;s API. This approach is particularly handy for features that are inherently temporary, such as specialized pages to handle a sporting event. Such a part of the website can quickly be put together using rapid development languages, and removed once the event is over. We&#39;ve seen similar approaches at a financial institution where new services are added for a market opportunity and discarded after a few months or even weeks.</code></p><p>可代替性的重点是模块化设计原则中的特例，它是通过变化模式来驱动模块化。你希望在同一模块中保持同时更改的内容。很少变化的系统部分应该与目前正在经历大量变动的系统处于不同的服务中。如果你发现两个服务一直重复的变更时，这就是一个要合并它们的信号了。</p><p><code>This emphasis on replaceability is a special case of a more general principle of modular design, which is to drive modularity through the pattern of change. You want to keep things that change at the same time in the same module. Parts of a system that change rarely should be in different services to those that are currently undergoing lots of churn. If you find yourself repeatedly changing two services together, that&#39;s a sign that they should be merged.</code></p><p>将组件放入服务中可以更细化的发布计划。对于整体架构风格，任何更改都需要完整构建和部署整个应用程序。但是，使用微服务，你只需要重新部署您修改的服务。这可以简化并加快发布过程。缺点是你必须担心一项服务的变化会影响其消费者。传统的集成方法是尝试使用版本控制来解决这个问题，但微服务的世界中版本控制仅仅作为最后的手段。我们可以在设计服务时尽可能的容忍供应商的变化，来避免大量的版本控制。</p><p><code>Putting components into services adds an opportunity for more granular release planning. With a monolith any changes require a full build and deployment of the entire application. With microservices, however, you only need to redeploy the service(s) you modified. This can simplify and speed up the release process. The downside is that you have to worry about changes to one service breaking its consumers. The traditional integration approach is to try to deal with this problem using versioning, but the preference in the microservice world is to only use versioning as a last resort. We can avoid a lot of versioning by designing services to be as tolerant as possible to changes in their suppliers.</code></p><h2 id="微服务是未来吗？"><a href="#微服务是未来吗？" class="headerlink" title="微服务是未来吗？"></a>微服务是未来吗？</h2><p>我们写这篇文章的主要目的是解释微服务的主要思想和原则。花时间来做这事，我们清楚地认识到使用微服务架构风格是一个值得企业认真考虑的重要想法。我们最近使用这种风格构建了几个系统，并了解了其他使用和喜欢这种方法的人。</p><p><code>Our main aim in writing this article is to explain the major ideas and principles of microservices. By taking the time to do this we clearly think that the microservices architectural style is an important idea - one worth serious consideration for enterprise applications. We have recently built several systems using the style and know of others who have used and favor this approach.</code></p><p>我们认识的使用这种方式的先行者，包含亚马逊，Netflix，卫报，英国政府数字服务，realestate.com.au，Forward和comparethemarket.com。2013年的巡回会议充满了正想成为微服务一分子的公司，包括Travis CI。此外，有很多组织长期以来一直在做我们称之为微服务的东西，但没有使用过这个名字。（通常这被称为SOA - 尽管，我们认为SOA有许多相互矛盾的形式。）</p><p><code>Those we know about who are in some way pioneering the architectural style include Amazon, Netflix, The Guardian, the UK Government Digital Service, realestate.com.au, Forward and comparethemarket.com. The conference circuit in 2013 was full of examples of companies that are moving to something that would class as microservices - including Travis CI. In addition there are plenty of organizations that have long been doing what we would class as microservices, but without ever using the name. (Often this is labelled as SOA - although, as we&#39;ve said, SOA comes in many contradictory forms.)</code></p><p>尽管有这些积极的经验，我们并不确信微服务是软件架构的未来发展方向。虽然到目前为止我们的经验与整体应用相比是积极的，但我们意识到没有足够的时间让我们做出充分的判断。</p><p><code>Despite these positive experiences, however, we aren&#39;t arguing that we are certain that microservices are the future direction for software architectures. While our experiences so far are positive compared to monolithic applications, we&#39;re conscious of the fact that not enough time has passed for us to make a full judgement.</code></p><p>通常，你制定的架构风格的实际成果只有在几年后才会明显。我们已经看到一些强大的团队项目，带着强烈的模块化意愿建立的整体架构，在几年后开始腐坏了。许多人认为，微服务不太可能出现这种衰退，因为服务边界是明确的，很再完善了。然而，我们还没有看到足够多的系统运行足够长的时间，所以我们无法肯定微服务架构是成熟的。</p><p><code>Often the true consequences of your architectural decisions are only evident several years after you made them. We have seen projects where a good team, with a strong desire for modularity, has built a monolithic architecture that has decayed over the years. Many people believe that such decay is less likely with microservices, since the service boundaries are explicit and hard to patch around. Yet until we see enough systems with enough age, we can&#39;t truly assess how microservice architectures mature.</code></p><p>当然，还有原因就是，有人期望微服务构架不够成熟。在为组件化的做出努力中，成功取决于软件拆分成组件的适用程度。很难弄清楚组件边界的确切位置。指出组件化的准确边界应该在那，这是非常困难的。但是当你的组件是具有远程通信的服务时，则重构比使用进程内库更难。跨服务边界移动代码是困难的，任何接口更改都需要在参与者之间进行协调，需要添加向后兼容层，并且测试变得更加复杂。</p><p><code>There are certainly reasons why one might expect microservices to mature poorly. In any effort at componentization, success depends on how well the software fits into components. It&#39;s hard to figure out exactly where the component boundaries should lie. Evolutionary design recognizes the difficulties of getting boundaries right and thus the importance of it being easy to refactor them. But when your components are services with remote communications, then refactoring is much harder than with in-process libraries. Moving code is difficult across service boundaries, any interface changes need to be coordinated between participants, layers of backwards compatibility need to be added, and testing is made more complicated.</code></p><p>另一个问题是如果组件没有清晰地划分，那么您所做的就是将复杂性从组件内部转移到组件之间的连接。这不仅仅是移动复杂性，而是将其移动到一个不那么明确且难以控制的地方。当你看到一个缺少服务之间的混乱连接且小而简单的组件内部时，很容易认为这样更好。</p><p><code>Another issue is If the components do not compose cleanly, then all you are doing is shifting complexity from inside a component to the connections between components. Not just does this just move complexity around, it moves it to a place that&#39;s less explicit and harder to control. It&#39;s easy to think things are better when you are looking at the inside of a small, simple component, while missing messy connections between services.</code></p><p>最后，团队技能也是重要的因素。新技术往往被更熟练的团队所采用。但是对于技能更高的团队来说更有效的技术并不一定适用于技能较低的团队。我们已经看到很多不太熟练的团队构建凌乱的整体架构，但是当微服务发生这种混乱时，需要花时间看看会发生什么。<br>一个糟糕的团队总是会创建一个糟糕的系统，很难说微服务是否可以减少这种情况下的混乱或使情况变得更糟。</p><p><code>Finally, there is the factor of team skill. New techniques tend to be adopted by more skillful teams. But a technique that is more effective for a more skillful team isn&#39;t necessarily going to work for less skillful teams. We&#39;ve seen plenty of cases of less skillful teams building messy monolithic architectures, but it takes time to see what happens when this kind of mess occurs with microservices. A poor team will always create a poor system - it&#39;s very hard to tell if microservices reduce the mess in this case or make it worse.</code></p><p>我们听到的一个合理的论点是，你不应该从微服务架构开始。最好从整体构架开发，做模块化开发，然后当整体构架出现问题是再把模块化拆分成服务。（这个建议并不理想，因为好的进程内接口通常不是一个好的服务接口。）</p><p><code>One reasonable argument we&#39;ve heard is that you shouldn&#39;t start with a microservices architecture. Instead begin with a monolith, keep it modular, and split it into microservices once the monolith becomes a problem. (Although this advice isn&#39;t ideal, since a good in-process interface is usually not a good service interface.)</code></p><p>因此我们持这种谨慎的乐观。到目前为止，我们已经看到了足够的微服务风格，觉得它可能是一条值得走的路。我们无法确定最终会在哪里结束，但软件开发的挑战之一是你只能在不完善信息中做出决策。</p><p><code>So we write this with cautious optimism. So far, we&#39;ve seen enough about the microservice style to feel that it can be a worthwhile road to tread. We can&#39;t say for sure where we&#39;ll end up, but one of the challenges of software development is that you can only make decisions based on the imperfect information that you currently have to hand.</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;微服务架构&quot;&gt;&lt;a href=&quot;#微服务架构&quot; class=&quot;headerlink&quot; title=&quot;微服务架构&quot;&gt;&lt;/a&gt;微服务架构&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简
      
    
    </summary>
    
      <category term="Micro Service" scheme="https://tenderlies.github.io/categories/Micro-Service/"/>
    
    
  </entry>
  
  <entry>
    <title>Hexo的使用方法</title>
    <link href="https://tenderlies.github.io/2018/06/05/Hexo%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/hexo%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/Github-Pages/"/>
    <id>https://tenderlies.github.io/2018/06/05/Hexo的使用方法/hexo的使用方法/Github-Pages/</id>
    <published>2018-06-04T18:15:00.000Z</published>
    <updated>2018-06-04T19:39:25.262Z</updated>
    
    <content type="html"><![CDATA[<p>把Hexo的使用攻略记下来吧。<br>此文章的目的是为了提醒自己一些Hexo的常用配置。若要详细配置<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">Hexo</a>与<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">Next主题</a>，请点击链接。</p><h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><p>首先，安装Node.js与Git，就不详细介绍了。<br>然后使用NPM安装Hexo</p><pre><code>npm install -g hexo-cli</code></pre><h2 id="配置站点"><a href="#配置站点" class="headerlink" title="配置站点"></a>配置站点</h2><p>使用Git克隆你的Github Pages项目，文件夹名为：<code>tenderlies.github.io</code><br>打开该文件夹，在路径上执行：<code>cmd</code><br>执行该命令初始化站点文件结构</p><pre><code>hexo init ./npm intall</code></pre><h2 id="部分指令"><a href="#部分指令" class="headerlink" title="部分指令"></a>部分指令</h2><ul><li><strong>初始化站点文件结构</strong><pre><code>  hexo init [folder]</code></pre></li><li><strong>显示hexo版本</strong><pre><code>  hexo version</code></pre></li><li><strong>列出文章资料</strong><pre><code>  hexo list post</code></pre></li><li><strong>清除缓存文件和已生成的静态文件</strong><pre><code>  hexo clean</code></pre></li><li><strong>新建一篇文章</strong><pre><code>  hexo new [layout] filename</code></pre></li><li><strong>启动服务器</strong><pre><code>  hexo s(erver)</code></pre></li><li><strong>生成静态文件</strong><pre><code>  hexo g(enerta)</code></pre></li><li><strong>部署网站</strong><pre><code>  hexo d(eploy)</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;把Hexo的使用攻略记下来吧。&lt;br&gt;此文章的目的是为了提醒自己一些Hexo的常用配置。若要详细配置&lt;a href=&quot;https://hexo.io/zh-cn/docs/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;
      
    
    </summary>
    
      <category term="Github Pages" scheme="https://tenderlies.github.io/categories/Github-Pages/"/>
    
    
  </entry>
  
  <entry>
    <title>Hello Blog</title>
    <link href="https://tenderlies.github.io/2018/05/22/hello-blog/hello-blog/Github-Pages/"/>
    <id>https://tenderlies.github.io/2018/05/22/hello-blog/hello-blog/Github-Pages/</id>
    <published>2018-05-22T10:47:14.465Z</published>
    <updated>2018-05-24T02:34:04.713Z</updated>
    
    <content type="html"><![CDATA[<p>这是我的第一个博客，这是一个搭建在GitHub上的博客。<br>这种静态博客框架的主流有两种：<a href="http://jekyllcn.com/docs/home/" target="_blank" rel="noopener">Jekyll</a>与<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">Hexo</a>。这两个框架都是使用<a href="https://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">Markdown</a>（一种纯文本格式语法）解析文章，然后生成静态网页。<br>GitHub是使用Jekyll去重建你的网页，由于Jekyll的安装好麻烦，所以就使用Hexo来做框架吧。</p><p>ps:Hexo的安装、目录结构、配置就看这个<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">链接</a>吧。</p><h2 id="熟悉一下各种Markdownn的写法吧。"><a href="#熟悉一下各种Markdownn的写法吧。" class="headerlink" title="熟悉一下各种Markdownn的写法吧。"></a>熟悉一下各种Markdownn的写法吧。</h2><p><a href="https://daringfireball.net/projects/markdown/" style="font-weight: bold" target="_blank" rel="noopener">Markdown</a>是支持直接在非标签内直接书写html语法的。比如，加粗的Markdown超链接就是用a标签来写的- -。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;https://daringfireball.net/projects/markdown/&quot; style=&quot;font-weight: bold&quot;&gt;Markdown&lt;/a&gt;是支持直接在非标签内直接书写html语法的。比如，加粗的Markdown超链接就是用a标签来写的- -。</span><br></pre></td></tr></table></figure><p>这个时候你可能会想：如果我想在页面上显示一个&amp;符号，是不是应该用<code>&amp;amp;</code>来代替呢？答案是：都行，直接使用&amp;符号就可以啦。</p><h3 id="标题标签"><a href="#标题标签" class="headerlink" title="标题标签"></a>标题标签</h3><pre><code>## h2标签### h3标签####### h6标签</code></pre><p>看如上示例👆</p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><p><ul><br>    <li>html实现</li><br>    <li>html实现</li><br></ul></p><ul><li>使用* 也可以实现</li></ul><ul><li>使用+ 也可以实现</li></ul><ul><li>使用- 也可以实现</li></ul><ul><li>还可以混用哟！</li></ul><p>写法如下  👇：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;html实现&lt;/li&gt; </span><br><span class="line">    &lt;li&gt;html实现&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p><pre><code>* 使用* 可以实现+ 使用+ 也可以实现- 使用- 也可以实现* 还可以混用哟！</code></pre><h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><ol><li>使用1. 可以实现</li><li>使用2. 可以实现，这是一段很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长的段落。</li><li>使用3. 可以实现</li></ol><p>写法如下  👇：</p><pre><code>1. 使用1. 可以实现2. 使用2. 可以实现，这是一段很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长的段落。3. 使用3. 可以实现</code></pre><p>当然，如果你想输出：</p><pre><code>1874. 刚刚早一百年一个世纪~是否终身都这样顽强地等</code></pre><p>会发现变成了这样：</p><ol start="1874"><li>刚刚早一百年一个世纪~<br>是否终身都这样顽强地等</li></ol><p>这个时候你需要做的是,将文本修改成下面这样:</p><pre><code>1874\. 刚刚早一百年一个世纪~是否终身都这样顽强地等</code></pre><p>才会这样输出：</p><p>1874. 刚刚早一百年一个世纪~<br>是否终身都这样顽强地等</p><h3 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h3><p>使用<code>&lt;pre</code>&gt;<code>&lt;code</code>&gt;与<code>&lt;/code</code>&gt;<code>&lt;/pre</code>&gt;将代码块包起来即可，或者是在代码的每一行使用4个空格或者一个制表符。</p><pre><code>这个一段代码 。</code></pre><pre><code>这也是一段代码这是第二段代码    我还可以缩进哦</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">`&lt;pre`&gt;`&lt;code`&gt;</span><br><span class="line">这个一段代码 。</span><br><span class="line">`&lt;/code`&gt;`&lt;/pre`&gt;</span><br><span class="line"></span><br><span class="line">    这也是一段代码</span><br><span class="line">    这是第二段代码</span><br><span class="line">        我还可以缩进哦</span><br></pre></td></tr></table></figure><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>样式如下：</p><hr><hr><hr><p>代码如下，重复3个以上就行哦，还可以穿插空格的哦：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">***</span><br><span class="line">_ __</span><br></pre></td></tr></table></figure></p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><h4 id="行内链接"><a href="#行内链接" class="headerlink" title="行内链接"></a>行内链接</h4><p><a href="https://tenderlies.github.io/">这是一个链接</a><br><a href="https://tenderlies.github.io/" title="我是标题">这是一个带标题的链接</a></p><p>写法如下  👇：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[这是一个链接](https://tenderlies.github.io/)</span><br><span class="line">[这是一个带标题的链接](https://tenderlies.github.io/ &quot;我是标题&quot;)</span><br></pre></td></tr></table></figure></p><h4 id="参考式链接"><a href="#参考式链接" class="headerlink" title="参考式链接"></a>参考式链接</h4><p><a href="https://daringfireball.net/projects/markdown/syntax#link" target="_blank" rel="noopener">参考式链接写法</a></p><h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><p><em>头尾各一个星号</em><br><em>头尾各一个下划线号</em><br><strong>头尾各两个星号</strong><br><strong>头尾各两个下划线号</strong></p><p>写法如下  👇：</p><pre><code>    *头尾各一个星号*    _头尾各一个下划线号_    **头尾各两个星号**    __头尾各两个下划线号__</code></pre><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p><img src="https://avatars0.githubusercontent.com/u/21984442?s=40&amp;v=4" alt="图片的Alt"></p><p>写法如下  👇：</p><pre><code>![图片的Alt](https://avatars0.githubusercontent.com/u/21984442?s=40&amp;v=4)</code></pre><h3 id="自动连接"><a href="#自动连接" class="headerlink" title="自动连接"></a>自动连接</h3><p>Markdown在线编辑器：<a href="http://dillinger.io/" target="_blank" rel="noopener">http://dillinger.io/</a><br>发送给：<a href="mailto:&#x65;&#120;&#x61;&#109;&#x70;&#108;&#101;&#64;&#104;&#x6f;&#116;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#109;" target="_blank" rel="noopener">&#x65;&#120;&#x61;&#109;&#x70;&#108;&#101;&#64;&#104;&#x6f;&#116;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#109;</a><br>点击试试  👆<br>写法如下  👇</p><pre><code>Markdown在线编辑器：&lt;http://dillinger.io/&gt;发送给：&lt;example@hotmail.com&gt;</code></pre><h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p>使用反斜杠（\）就好了啦~<br>需要转义的符号：</p><ul><li>\        反斜线</li><li>`        反引号</li><li>*        星号</li><li>_        底线</li><li>{}      花括号</li><li>[]      方括号</li><li>()      括弧</li><li>#        井字号</li><li>+        加号</li><li>-        减号</li><li>.        英文句点</li><li>!        惊叹号</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是我的第一个博客，这是一个搭建在GitHub上的博客。&lt;br&gt;这种静态博客框架的主流有两种：&lt;a href=&quot;http://jekyllcn.com/docs/home/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Jekyll&lt;/a&gt;与&lt;a href
      
    
    </summary>
    
      <category term="Github Pages" scheme="https://tenderlies.github.io/categories/Github-Pages/"/>
    
    
  </entry>
  
</feed>
